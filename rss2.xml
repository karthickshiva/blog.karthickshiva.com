<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Karthick Shiva</title>
    <link>https://blog.karthickshiva.dev/</link>
    
    <atom:link href="https://blog.karthickshiva.dev/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Valuable insights and practical advice on a range of technical topics from a seasoned software developer.</description>
    <pubDate>Tue, 25 Apr 2023 03:53:50 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>From Shipping Containers to Kubernetes: A Brief History of Containerization</title>
      <link>https://blog.karthickshiva.dev/2023/04/24/from-shipping-containers-to-kubernetes-a-brief-history-of-containerization/</link>
      <guid>https://blog.karthickshiva.dev/2023/04/24/from-shipping-containers-to-kubernetes-a-brief-history-of-containerization/</guid>
      <pubDate>Mon, 24 Apr 2023 14:08:14 GMT</pubDate>
      
      <description>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Containerization has come a long way since the days of shipping containers. In the world of technology, containerization has become a popular way to package and deploy applications. One of the most popular containerization platforms is Kubernetes. In this post, we’ll take a look at the history of containerization and how it has evolved to become the powerful platform that is Kubernetes.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description>
      
      
      
      <content:encoded><![CDATA[<html><head></head><body><p>Containerization has come a long way since the days of shipping containers. In the world of technology, containerization has become a popular way to package and deploy applications. One of the most popular containerization platforms is Kubernetes. In this post, we’ll take a look at the history of containerization and how it has evolved to become the powerful platform that is Kubernetes.</p><span id="more"></span><h2 id="The-Early-Days-of-Containerization"><a href="#The-Early-Days-of-Containerization" class="headerlink" title="The Early Days of Containerization"></a>The Early Days of Containerization</h2><p>The concept of containerization dates back to the 1950s, when shipping companies were looking for a way to transport goods more efficiently. The shipping industry developed standardized containers that could be easily loaded onto ships, trains, and trucks. This made it easier to transport goods across long distances and reduced the cost of shipping.</p><p>In the 1970s, the concept of containerization was applied to the world of computing. The idea was to create a standardized way to package and deploy software applications. This would make it easier to move applications between different environments, such as development, testing, and production.</p><h2 id="The-Rise-of-Virtualization"><a href="#The-Rise-of-Virtualization" class="headerlink" title="The Rise of Virtualization"></a>The Rise of Virtualization</h2><p>In the 1990s, virtualization became a popular way to package and deploy applications. Virtualization allowed multiple applications to run on a single server, making it more efficient and cost-effective. However, virtualization had its drawbacks. It was resource-intensive and required a lot of overhead.</p><h2 id="The-Birth-of-Docker"><a href="#The-Birth-of-Docker" class="headerlink" title="The Birth of Docker"></a>The Birth of Docker</h2><p>In 2013, Docker was introduced as a new way to package and deploy applications. Docker was built on top of the Linux container technology and provided a way to package applications in a lightweight and portable container. Docker quickly became popular and was adopted by many companies.</p><h2 id="The-Emergence-of-Kubernetes"><a href="#The-Emergence-of-Kubernetes" class="headerlink" title="The Emergence of Kubernetes"></a>The Emergence of Kubernetes</h2><p>As more companies started to use Docker, they realized that managing containers at scale was a challenge. This led to the development of Kubernetes, an open-source container orchestration platform. Kubernetes was designed to automate the deployment, scaling, and management of containerized applications.</p><p>Kubernetes provides a way to manage and orchestrate containers across multiple hosts, making it easier to deploy and manage applications at scale. Kubernetes provides a declarative API that allows you to define the desired state of your application, and it takes care of the rest.</p><h2 id="Kubernetes-Explained"><a href="#Kubernetes-Explained" class="headerlink" title="Kubernetes Explained"></a>Kubernetes Explained</h2><p>Suppose you have a web application that consists of multiple microservices. Each microservice is packaged in a Docker container and runs on a separate server. You want to deploy this application to a Kubernetes cluster and manage it using Kubernetes.</p><p>First, you would create a Kubernetes deployment that defines the desired state of your application. The deployment would specify the number of replicas for each microservice, the Docker image to use, and any other configuration options.</p><p>Next, you would create a Kubernetes service that exposes your application to the outside world. The service would provide a stable IP address and DNS name for your application, and it would load balance traffic across the replicas of each microservice.</p><p>Once you have created the deployment and service, Kubernetes takes care of the rest. Kubernetes monitors the state of your application and ensures that the actual state matches the desired state. If a container fails, Kubernetes automatically restarts it. If a server goes down, Kubernetes automatically reschedules the containers on a different server.</p><p>Kubernetes also provides a way to scale your application up or down based on demand. You can manually scale your application by updating the number of replicas in the deployment, or you can use Kubernetes’ autoscaling feature to automatically scale your application based on CPU usage, memory usage, or custom metrics.</p><p>Kubernetes also provides a way to manage application updates and rollbacks. With Kubernetes, you can deploy new versions of your application without downtime. If something goes wrong, you can easily roll back to the previous version.</p><h2 id="Real-Life-Solutions-with-Kubernetes"><a href="#Real-Life-Solutions-with-Kubernetes" class="headerlink" title="Real Life Solutions with Kubernetes"></a>Real Life Solutions with Kubernetes</h2><p>Kubernetes has become the de facto standard for container orchestration, and it’s used by many companies, including Airbnb, Spotify, and Lyft. These companies use Kubernetes to manage their applications at scale and provide a reliable and scalable service to their users.</p><p>If you’re interested in using Kubernetes, there are many resources available to help you get started. The <a href="https://kubernetes.io/docs/home/">Kubernetes documentation</a> is a great place to start, and there are many tutorials and courses available online. You can also use managed Kubernetes services like <a href="https://cloud.google.com/kubernetes-engine">Google Kubernetes Engine (GKE)</a>, <a href="https://aws.amazon.com/pm/eks/">Amazon Elastic Kubernetes Service (EKS)</a>, or <a href="https://azure.microsoft.com/en-us/products/kubernetes-service">Microsoft Azure Kubernetes Service (AKS)</a> to make it easier to deploy and manage your applications.</p><p>Containerization has come a long way since the days of shipping containers. Kubernetes has become a powerful platform that can help businesses manage their applications at scale. If you’re looking to manage your applications more efficiently, Kubernetes is definitely worth considering.</p></body></html>]]></content:encoded>
      
      
      <category domain="https://blog.karthickshiva.dev/categories/technology/">Technology</category>
      
      
      <category domain="https://blog.karthickshiva.dev/tags/system-design/">system-design</category>
      
      
      <comments>https://blog.karthickshiva.dev/2023/04/24/from-shipping-containers-to-kubernetes-a-brief-history-of-containerization/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Implementing Unique ID Generator</title>
      <link>https://blog.karthickshiva.dev/2023/04/22/Implementing-Unique-ID-Generator/</link>
      <guid>https://blog.karthickshiva.dev/2023/04/22/Implementing-Unique-ID-Generator/</guid>
      <pubDate>Sat, 22 Apr 2023 06:42:52 GMT</pubDate>
      
      <description>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;A unique ID generator can be implemented using a combination of timestamp, counter, and random number. Here’s a possible implementation in Python:&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description>
      
      
      
      <content:encoded><![CDATA[<html><head></head><body><p>A unique ID generator can be implemented using a combination of timestamp, counter, and random number. Here’s a possible implementation in Python:</p><span id="more"></span><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"><span class="hljs-keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="title class_">IDGenerator</span>:</span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="title function_">__init__</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        self.counter = <span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="title function_">generate_id</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        timestamp = <span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span>)  <span class="hljs-comment"># Get current timestamp in milliseconds</span></span><br><span class="line">        self.counter = (self.counter + <span class="hljs-number">1</span>) % <span class="hljs-number">10000</span>  <span class="hljs-comment"># Increment counter and wrap around</span></span><br><span class="line">        random_num = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">999</span>)  <span class="hljs-comment"># Generate random number between 0 and 999</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{timestamp:013d}</span><span class="hljs-subst">{self.counter:04d}</span><span class="hljs-subst">{random_num:03d}</span>"</span></span><br></pre></td></tr></tbody></table></figure><p>In this implementation, the <code>IDGenerator</code> class has a counter initialized to zero. The <code>generate_id</code> method generates a unique ID by concatenating the current timestamp in milliseconds, a counter value that increments with each ID generation, and a random number between 0 and 999. The resulting ID is a 20-digit string in the format <code>timestamp (13 digits) + counter (4 digits) + random number (3 digits)</code>.</p><p>Here’s an example of how to use the <code>IDGenerator</code> class:</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generator = IDGenerator()</span><br><span class="line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):</span><br><span class="line">    <span class="hljs-built_in">print</span>(generator.generate_id())</span><br></pre></td></tr></tbody></table></figure><p>This code creates an instance of the <code>IDGenerator</code> class and generates 10 unique IDs using the <code>generate_id</code> method. The output might look like this:</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">162798978283100000000000</span><br><span class="line">162798978283100000000001</span><br><span class="line">162798978283100000000002</span><br><span class="line">162798978283100000000003</span><br><span class="line">162798978283100000000004</span><br><span class="line">162798978283100000000005</span><br><span class="line">162798978283100000000006</span><br><span class="line">162798978283100000000007</span><br><span class="line">162798978283100000000008</span><br><span class="line">162798978283100000000009</span><br></pre></td></tr></tbody></table></figure><p>This implementation generates unique IDs by combining a timestamp, a counter, and a random number, which ensures that the probability of collisions is very low. <b>However, it is possible for collisions to occur if the same ID generator is used across multiple machines or if the counter wraps around too quickly.</b> To further optimize the ID generator, additional measures such as using a stronger hash function or a distributed ID generation system may be necessary.</p><h2 id="Other-options"><a href="#Other-options" class="headerlink" title="Other options:"></a>Other options:</h2><p>There are several options to generate unique IDs, depending on the requirements of the application. Here are some common methods:</p><ol><li><p>UUID: A UUID (Universally Unique Identifier) is a 128-bit number that is guaranteed to be unique across time and space. UUIDs are generated using a combination of timestamp and random number, and can be represented as a string of hexadecimal digits.</p></li><li><p>Timestamp: A timestamp is a value that represents the current date and time. Timestamps can be used as unique IDs if they are combined with a counter or a random number to ensure uniqueness.</p></li><li><p>Counter: A counter is a value that increments with each ID generation. Counters can be used as unique IDs if they are combined with a timestamp or a random number to ensure uniqueness.</p></li><li><p>Hash function: A hash function can be used to generate a unique ID from a given input. Hash functions take an input of arbitrary size and produce a fixed-size output that is unique for each input value.</p></li><li><p>Snowflake ID: A Snowflake ID is a unique 64-bit integer that is generated using a combination of timestamp, machine ID, and sequence number. Snowflake IDs are used by distributed systems to generate unique IDs across multiple machines.</p></li><li><p>Custom ID: A custom ID can be generated using any combination of the above methods, or by using a custom algorithm that meets the specific requirements of the application.</p></li></ol><p>Each of these methods has its own advantages and disadvantages, and the choice of ID generation method depends on the specific requirements of the application. For example, UUIDs are widely used because they are guaranteed to be unique, but they are relatively long and may not be suitable for some applications. On the other hand, counters are simple and efficient, but they may not be unique if multiple ID generators are used simultaneously.</p><h3 id="Auto-Incremented-ID"><a href="#Auto-Incremented-ID" class="headerlink" title="Auto Incremented ID:"></a>Auto Incremented ID:</h3><p>Using auto-incremented IDs as primary keys in SQL databases is a common practice and works well in many cases. However, there are some situations where this approach may not be suitable:</p><ol><li><p>Scalability: If the database is expected to grow very large, auto-incremented IDs may eventually overflow the maximum value of the data type used to store them. This can cause errors and require expensive database migrations.</p></li><li><p>Security: Auto-incremented IDs can be predictable, which can be a security risk if they are used in URLs or other public-facing contexts. Attackers can use this predictability to guess other IDs and access sensitive data.</p></li><li><p>Data privacy: In some cases, auto-incremented IDs can reveal information about the data, such as the order in which it was added to the database. This can be a privacy concern if the data contains sensitive information.</p></li><li><p>Data integration: If data from multiple databases needs to be merged or integrated, auto-incremented IDs may not be unique across the different databases, leading to conflicts and errors.</p></li></ol><p>For these reasons, it may be necessary to use other methods to generate unique IDs, such as UUIDs or custom ID generators. These methods can provide better scalability, security, and data privacy, and can be more suitable for distributed systems or applications with complex data integration requirements.</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID:"></a>UUID:</h3><p>UUIDs (Universally Unique Identifiers) are widely used as unique identifiers in many applications and have several advantages, such as being guaranteed to be unique and not requiring a centralized ID generator. However, there are some situations where UUIDs may not be suitable:</p><ol><li><p>Size: UUIDs are relatively long, typically 32 hexadecimal digits (128 bits). This can be a problem if the IDs need to be stored in a database or transmitted over a network, as it can increase storage and bandwidth requirements.</p></li><li><p>Predictability: Although UUIDs are designed to be unique, they are not completely random and can be predictable in some cases. This can be a security risk if the UUIDs are used in URLs or other public-facing contexts.</p></li><li><p>Performance: Generating UUIDs can be computationally expensive, especially if they are generated in large batches or in a distributed system. This can affect the performance of the application and increase response times.</p></li><li><p>Integration: If data from multiple systems needs to be merged or integrated, UUIDs may not be unique across the different systems, leading to conflicts and errors.</p></li></ol><p>For these reasons, it may be necessary to use other methods to generate unique IDs, such as custom ID generators or other types of UUIDs (such as ULIDs or Flake IDs) that address some of the limitations of standard UUIDs. The choice of ID generation method depends on the specific requirements of the application and the trade-offs between uniqueness, size, predictability, and performance.</p><h3 id="Snowflake-ID"><a href="#Snowflake-ID" class="headerlink" title="Snowflake ID:"></a>Snowflake ID:</h3><p>Snowflake ID is a unique 64-bit integer that is generated using a combination of timestamp, machine ID, and sequence number. Snowflake IDs are used by distributed systems to generate unique IDs across multiple machines. Here’s an example of how Snowflake ID is generated:</p><p>Let’s assume that we have a distributed system with multiple machines. Each machine has a unique ID, which is a 10-bit integer. The current timestamp in milliseconds is 41 bits long. The sequence number is a 12-bit integer that increments with each ID generation on the same machine.</p><p>To generate a Snowflake ID, we can concatenate these three values into a 64-bit integer in the following order:</p><ol><li>The first 41 bits represent the current timestamp in milliseconds.</li><li>The next 10 bits represent the machine ID.</li><li>The last 12 bits represent the sequence number.</li></ol><p>Here’s an example of how a Snowflake ID might look like:</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110011001101001110101011110010011101001110000000000000000000000 (64 bits)</span><br></pre></td></tr></tbody></table></figure><p>In this example, the first 41 bits represent the timestamp, which is equivalent to the value <code>1630055836000</code> in milliseconds. The next 10 bits represent the machine ID, which could be any value between 0 and 1023. The last 12 bits represent the sequence number, which could be any value between 0 and 4095.</p><p>By using a combination of timestamp, machine ID, and sequence number, Snowflake IDs can be generated with a high degree of uniqueness and can be used to generate IDs across multiple machines in a distributed system.</p><p>Here’s an implementation of the Snowflake method for generating unique IDs in Python:</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">class</span> <span class="title class_">SnowflakeGenerator</span>:</span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="title function_">__init__</span>(<span class="hljs-params">self, datacenter_id, worker_id</span>):</span><br><span class="line">        self.twepoch = <span class="hljs-number">1288834974657</span></span><br><span class="line">        self.datacenter_id = datacenter_id</span><br><span class="line">        self.worker_id = worker_id</span><br><span class="line">        self.sequence = <span class="hljs-number">0</span></span><br><span class="line">        self.sequence_bits = <span class="hljs-number">12</span></span><br><span class="line">        self.worker_id_bits = <span class="hljs-number">5</span></span><br><span class="line">        self.datacenter_id_bits = <span class="hljs-number">5</span></span><br><span class="line">        self.max_worker_id = -<span class="hljs-number">1</span> ^ (-<span class="hljs-number">1</span> &lt;&lt; self.worker_id_bits)</span><br><span class="line">        self.max_datacenter_id = -<span class="hljs-number">1</span> ^ (-<span class="hljs-number">1</span> &lt;&lt; self.datacenter_id_bits)</span><br><span class="line">        self.sequence_mask = -<span class="hljs-number">1</span> ^ (-<span class="hljs-number">1</span> &lt;&lt; self.sequence_bits)</span><br><span class="line">        self.worker_id_shift = self.sequence_bits</span><br><span class="line">        self.datacenter_id_shift = self.sequence_bits + self.worker_id_bits</span><br><span class="line">        self.timestamp_shift = self.sequence_bits + self.worker_id_bits + self.datacenter_id_bits</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="title function_">_generate_timestamp</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(time.time() * <span class="hljs-number">1000</span> - self.twepoch)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="title function_">_next_sequence</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        self.sequence = (self.sequence + <span class="hljs-number">1</span>) &amp; self.sequence_mask</span><br><span class="line">        <span class="hljs-keyword">if</span> self.sequence == <span class="hljs-number">0</span>:</span><br><span class="line">            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"Sequence overflow"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">def</span> <span class="title function_">generate_id</span>(<span class="hljs-params">self</span>):</span><br><span class="line">        timestamp = self._generate_timestamp()</span><br><span class="line">        <span class="hljs-keyword">if</span> timestamp &lt; self.last_timestamp:</span><br><span class="line">            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">"Clock moved backwards"</span>)</span><br><span class="line">        <span class="hljs-keyword">if</span> timestamp == self.last_timestamp:</span><br><span class="line">            self._next_sequence()</span><br><span class="line">        <span class="hljs-keyword">else</span>:</span><br><span class="line">            self.sequence = <span class="hljs-number">0</span></span><br><span class="line">        self.last_timestamp = timestamp</span><br><span class="line">        <span class="hljs-keyword">return</span> ((timestamp &lt;&lt; self.timestamp_shift) |</span><br><span class="line">                (self.datacenter_id &lt;&lt; self.datacenter_id_shift) |</span><br><span class="line">                (self.worker_id &lt;&lt; self.worker_id_shift) |</span><br><span class="line">                self.sequence)</span><br></pre></td></tr></tbody></table></figure><p>Here’s how you can use this class to generate unique IDs:</p><figure class="highlight python hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generator = SnowflakeGenerator(datacenter_id=<span class="hljs-number">1</span>, worker_id=<span class="hljs-number">1</span>)</span><br><span class="line">unique_id = generator.generate_id()</span><br><span class="line"><span class="hljs-built_in">print</span>(unique_id)</span><br></pre></td></tr></tbody></table></figure><p>This will output a unique ID that is generated using the Snowflake method. You can change the <code>datacenter_id</code> and <code>worker_id</code> values to generate IDs that are unique to your specific environment.</p><p>The code is an implementation of the Snowflake method for generating unique IDs in Python.</p><p>The <code>SnowflakeGenerator</code> class has the following attributes:</p><ul><li><code>twepoch</code>: This is the timestamp of the Snowflake epoch, which is January 1, 2010 in milliseconds. It is used to calculate the timestamp portion of the generated ID.</li><li><code>datacenter_id</code>: This is a unique identifier for the datacenter that the ID is being generated in.</li><li><code>worker_id</code>: This is a unique identifier for the worker that is generating the ID.</li><li><code>sequence</code>: This is a counter that is used to ensure that IDs generated within the same millisecond are unique.</li><li><code>sequence_bits</code>: This is the number of bits used to represent the sequence number.</li><li><code>worker_id_bits</code>: This is the number of bits used to represent the worker ID.</li><li><code>datacenter_id_bits</code>: This is the number of bits used to represent the datacenter ID.</li><li><code>max_worker_id</code>: This is the maximum value that the worker ID can be.</li><li><code>max_datacenter_id</code>: This is the maximum value that the datacenter ID can be.</li><li><code>sequence_mask</code>: This is a bitmask that is used to extract the sequence number from the generated ID.</li><li><code>worker_id_shift</code>: This is the number of bits to shift the worker ID to the left before combining it with the other parts of the ID.</li><li><code>datacenter_id_shift</code>: This is the number of bits to shift the datacenter ID to the left before combining it with the other parts of the ID.</li><li><code>timestamp_shift</code>: This is the number of bits to shift the timestamp to the left before combining it with the other parts of the ID.</li></ul><p>The <code>SnowflakeGenerator</code> class has the following methods:</p><ul><li><code>_generate_timestamp()</code>: This method generates the timestamp portion of the ID by subtracting the Snowflake epoch from the current time in milliseconds.</li><li><code>_next_sequence()</code>: This method increments the sequence number and handles sequence number overflow.</li><li><code>generate_id()</code>: This method generates a unique ID using the Snowflake method. It combines the timestamp, datacenter ID, worker ID, and sequence number to create a 64-bit ID.</li></ul><p>To use the <code>SnowflakeGenerator</code> class, you can create an instance of the class with a unique datacenter ID and worker ID, and then call the <code>generate_id()</code> method to generate a new ID. The generated ID will be unique to your specific environment.</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>The Snowflake method was originally developed by Twitter to generate unique IDs for their distributed systems. They chose January 1, 2010 as the epoch for their implementation of the Snowflake method because it was a recent date at the time and it allowed for a larger range of timestamps than if they had chosen an earlier epoch.</p><p>In the Snowflake method, the timestamp portion of the ID is calculated by subtracting the epoch time from the current time in milliseconds. By choosing a more recent epoch time, the timestamp portion of the ID can be represented using fewer bits, which allows for a larger range of timestamps to be represented in the ID.</p><p>It’s worth noting that the choice of epoch time is somewhat arbitrary and can be adjusted to suit the needs of a particular system. However, it’s important to choose an epoch time that allows for a sufficient range of timestamps to be represented in the ID, while also ensuring that the timestamp portion of the ID doesn’t take up too many bits and reduce the number of bits available for other parts of the ID (such as the worker ID and sequence number).</p></body></html>]]></content:encoded>
      
      
      <category domain="https://blog.karthickshiva.dev/categories/system-design/">System Design</category>
      
      
      <category domain="https://blog.karthickshiva.dev/tags/system-design/">system-design</category>
      
      
      <comments>https://blog.karthickshiva.dev/2023/04/22/Implementing-Unique-ID-Generator/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://blog.karthickshiva.dev/2023/04/22/Dependency-Injection/</link>
      <guid>https://blog.karthickshiva.dev/2023/04/22/Dependency-Injection/</guid>
      <pubDate>Sat, 22 Apr 2023 06:37:05 GMT</pubDate>
      
      <description>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Dependency injection is a design pattern used in software engineering that allows objects to be created with their dependencies supplied from outside sources. In other words, instead of an object creating its dependencies itself, the dependencies are “injected” into the object from an external source.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description>
      
      
      
      <content:encoded><![CDATA[<html><head></head><body><p>Dependency injection is a design pattern used in software engineering that allows objects to be created with their dependencies supplied from outside sources. In other words, instead of an object creating its dependencies itself, the dependencies are “injected” into the object from an external source.</p><span id="more"></span><p>The main benefits of dependency injection are:</p><ol><li><p>Decoupling: By injecting dependencies, objects are not tightly coupled to their dependencies, which makes them more modular and easier to test.</p></li><li><p>Testability: Because dependencies can be easily replaced with mock objects, unit testing becomes easier and more effective.</p></li><li><p>Reusability: Injected dependencies can be reused across multiple objects, reducing code duplication and improving maintainability.</p></li></ol><p>There are three main types of dependency injection:</p><ol><li><p>Constructor Injection: Dependencies are passed to an object’s constructor when it is created.</p></li><li><p>Setter Injection: Dependencies are set on an object using setter methods.</p></li><li><p>Interface Injection: Objects are required to implement a specific interface that defines the dependencies they require.</p></li></ol><p>Dependency injection frameworks are available in many programming languages to help automate the process of injecting dependencies. These frameworks use a combination of reflection and configuration files to automatically inject dependencies into objects at runtime. Examples of dependency injection frameworks include Spring Framework for Java and AngularJS for JavaScript.</p><p>Here are some examples of dependency injection in Java:</p><h2 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection:"></a>Constructor Injection:</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">UserService</span> {</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="title function_">UserService</span><span class="hljs-params">(UserRepository userRepository)</span> {</span><br><span class="line">        <span class="hljs-built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> User <span class="title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> {</span><br><span class="line">        <span class="hljs-keyword">return</span> userRepository.findById(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>In this example, the <code>UserService</code> class has a dependency on the <code>UserRepository</code> class, which is passed to its constructor. The <code>UserRepository</code> object is injected into the <code>UserService</code> object when it is created. This allows the <code>UserService</code> object to use the methods of the <code>UserRepository</code> object without creating it itself.</p><h2 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection:"></a>Setter Injection:</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">OrderService</span> {</span><br><span class="line">    <span class="hljs-keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">setPaymentService</span><span class="hljs-params">(PaymentService paymentService)</span> {</span><br><span class="line">        <span class="hljs-built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">processOrder</span><span class="hljs-params">(Order order)</span> {</span><br><span class="line">        paymentService.processPayment(order.getPayment());</span><br><span class="line">        <span class="hljs-comment">// process order logic</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>In this example, the <code>OrderService</code> class has a dependency on the <code>PaymentService</code> class, which is set using a setter method. The <code>PaymentService</code> object is injected into the <code>OrderService</code> object after it is created. This allows the <code>OrderService</code> object to use the methods of the <code>PaymentService</code> object without creating it itself.</p><h2 id="Interface-Injection"><a href="#Interface-Injection" class="headerlink" title="Interface Injection:"></a>Interface Injection:</h2><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="title class_">Logger</span> {</span><br><span class="line">    <span class="hljs-keyword">void</span> <span class="title function_">log</span><span class="hljs-params">(String message)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">ConsoleLogger</span> <span class="hljs-keyword">implements</span> <span class="title class_">Logger</span> {</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">log</span><span class="hljs-params">(String message)</span> {</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">UserService</span> {</span><br><span class="line">    <span class="hljs-keyword">private</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">setLogger</span><span class="hljs-params">(Logger logger)</span> {</span><br><span class="line">        <span class="hljs-built_in">this</span>.logger = logger;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> User <span class="title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> {</span><br><span class="line">        logger.log(<span class="hljs-string">"Getting user by id: "</span> + id);</span><br><span class="line">        <span class="hljs-comment">// get user logic</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>In this example, the <code>UserService</code> class has a dependency on the <code>Logger</code> interface, which is required to be implemented by any object that wants to be injected into the <code>UserService</code> object. The <code>ConsoleLogger</code> class implements the <code>Logger</code> interface and is injected into the <code>UserService</code> object using a setter method. This allows the <code>UserService</code> object to use the methods of the <code>Logger</code> object without creating it itself.</p><p>These are just a few examples of how dependency injection can be used in Java. There are many other ways to use dependency injection, and the specific implementation depends on the needs of the application.</p><p>Let’s say we have a class called “UserService” that is responsible for managing user data. This class has a dependency on a database connection to retrieve and store user data.</p><p>Without dependency injection, the UserService class would have to create its own database connection object, which would tightly couple the UserService class to the database connection implementation.</p><p>With dependency injection, we can pass in the database connection object as a dependency to the UserService class. This allows us to easily swap out different database connection implementations without having to modify the UserService class.</p><p>For example, we could create a <code>MySQLDatabaseConnection</code> class and a <code>PostgreSQLDatabaseConnection</code> class, both implementing the same interface. We can then pass in either of these objects to the UserService class depending on which database we want to use.</p><p>This makes our code more flexible and easier to maintain, as we can easily swap out dependencies without having to modify the code that uses them.</p></body></html>]]></content:encoded>
      
      
      <category domain="https://blog.karthickshiva.dev/categories/design-patterns/">Design Patterns</category>
      
      
      <category domain="https://blog.karthickshiva.dev/tags/design-patterns/">design-patterns</category>
      
      
      <comments>https://blog.karthickshiva.dev/2023/04/22/Dependency-Injection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Using Threading to Print Odd and Even Numbers in Order</title>
      <link>https://blog.karthickshiva.dev/2023/04/22/Using-Threading-to-Print-Odd-and-Even-Numbers-in-Order/</link>
      <guid>https://blog.karthickshiva.dev/2023/04/22/Using-Threading-to-Print-Odd-and-Even-Numbers-in-Order/</guid>
      <pubDate>Sat, 22 Apr 2023 06:01:22 GMT</pubDate>
      
      <description>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;In this blog post, we’ll explore how to use threading in Java to print odd and even numbers in order. Threading is a powerful technique that allows us to execute multiple threads of code concurrently, which can be useful for a wide variety of applications, including parallel processing, network programming, and more.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description>
      
      
      
      <content:encoded><![CDATA[<html><head></head><body><p>In this blog post, we’ll explore how to use threading in Java to print odd and even numbers in order. Threading is a powerful technique that allows us to execute multiple threads of code concurrently, which can be useful for a wide variety of applications, including parallel processing, network programming, and more.</p><span id="more"></span><p>In this example, we’ll use threading to print a sequence of odd and even numbers in order. We’ll start by creating two threads, one for printing odd numbers and one for printing even numbers. Each thread will execute a loop that prints the appropriate numbers, and we’ll use a synchronization primitive called a semaphore to ensure that the threads execute in the correct order.</p><p>By the end of this blog post, you’ll have a better understanding of how to use threading in Java to execute concurrent tasks.</p><p>We’re going to discuss about two major methods to implement this.</p><h2 id="Using-synchronized-method"><a href="#Using-synchronized-method" class="headerlink" title="Using synchronized method:"></a>Using <code>synchronized</code> method:</h2><p>In Java, the synchronized keyword is used to create synchronized methods, which are methods that can be accessed by only one thread at a time. When a thread invokes a synchronized method, it acquires a lock on the object that the method is called on, and no other thread can access the synchronized method on that object until the lock is released.</p><p>Here’s a sample Java code that creates two separate threads to print odd and even numbers:</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">OddEvenPrinter</span> {</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">main</span><span class="hljs-params">(String[] args)</span> {</span><br><span class="line">        <span class="hljs-type">OddEvenPrinter</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">OddEvenPrinter</span>();</span><br><span class="line">        <span class="hljs-type">Thread</span> <span class="hljs-variable">oddThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="hljs-string">"Odd"</span>);</span><br><span class="line">        <span class="hljs-type">Thread</span> <span class="hljs-variable">evenThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="hljs-string">"Even"</span>);</span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="title function_">printOdd</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">while</span> (currentValue &lt;= MAX_VALUE) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (currentValue % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + currentValue);</span><br><span class="line">                currentValue++;</span><br><span class="line">                notify();</span><br><span class="line">            } <span class="hljs-keyword">else</span> {</span><br><span class="line">                <span class="hljs-keyword">try</span> {</span><br><span class="line">                    wait();</span><br><span class="line">                } <span class="hljs-keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="title function_">printEven</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">while</span> (currentValue &lt;= MAX_VALUE) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (currentValue % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + currentValue);</span><br><span class="line">                currentValue++;</span><br><span class="line">                notify();</span><br><span class="line">            } <span class="hljs-keyword">else</span> {</span><br><span class="line">                <span class="hljs-keyword">try</span> {</span><br><span class="line">                    wait();</span><br><span class="line">                } <span class="hljs-keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>This code should print the following output:</p><figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Odd: 1</span><br><span class="line">Even: 2</span><br><span class="line">Odd: 3</span><br><span class="line">Even: 4</span><br><span class="line">Odd: 5</span><br><span class="line">Even: 6</span><br><span class="line">Odd: 7</span><br><span class="line">Even: 8</span><br><span class="line">Odd: 9</span><br><span class="line">Even: 10</span><br></pre></td></tr></tbody></table></figure><p>In this code, we define a <code>OddEvenPrinter</code> class that has a <code>MAX_VALUE</code> constant that specifies the maximum number to print, and a <code>currentValue</code> variable that keeps track of the current number to print.</p><p>We create two separate threads, one for printing odd numbers and one for printing even numbers, using the <code>Thread</code> class and lambda expressions.</p><p>The <code>printOdd()</code> and <code>printEven()</code> methods use a <code>synchronized</code> block to ensure that only one thread can access the shared <code>currentValue</code> variable at a time.</p><p>Within each method, we use a <code>while</code> loop to print odd and even numbers, respectively. If the current value is odd and the current thread is the odd thread, we print the current value and increment the <code>currentValue</code> variable, and then notify the other thread to wake up. If the current value is even and the current thread is the even thread, we print the current value and increment the <code>currentValue</code> variable, and then notify the other thread to wake up. Otherwise, we wait for the other thread to notify us.</p><p>By the end of this code, you should have two separate threads that print odd and even numbers in order.</p><h2 id="Using-Semaphores"><a href="#Using-Semaphores" class="headerlink" title="Using Semaphores:"></a>Using Semaphores:</h2><p>Semaphores are a synchronization mechanism that is used to control access to a shared resource in a concurrent system. They were first introduced by Edsger Dijkstra in 1965.</p><p>A semaphore is essentially a counter that is associated with a shared resource. The counter can be incremented or decremented by threads that wish to access the shared resource. When the counter is greater than zero, the resource is available for use. When the counter is zero, the resource is unavailable and threads that wish to access it must wait until it becomes available.</p><p>In Java, the Semaphore class is provided as part of the java.util.concurrent package. It provides methods for acquiring and releasing permits, which are equivalent to incrementing and decrementing the counter associated with the semaphore. Semaphores can be used in conjunction with other synchronization mechanisms such as locks and condition variables to implement more complex synchronization patterns.</p><p>Here’s a sample Java code that uses Semaphores to print odd and even numbers in order:</p><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="title class_">OddEvenPrinter</span> {</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">oddSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Semaphore</span>(<span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">evenSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Semaphore</span>(<span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="title function_">main</span><span class="hljs-params">(String[] args)</span> {</span><br><span class="line">        <span class="hljs-type">OddEvenPrinter</span> <span class="hljs-variable">printer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">OddEvenPrinter</span>();</span><br><span class="line">        <span class="hljs-type">Thread</span> <span class="hljs-variable">oddThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Thread</span>(printer::printOdd, <span class="hljs-string">"Odd"</span>);</span><br><span class="line">        <span class="hljs-type">Thread</span> <span class="hljs-variable">evenThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="title class_">Thread</span>(printer::printEven, <span class="hljs-string">"Even"</span>);</span><br><span class="line">        oddThread.start();</span><br><span class="line">        evenThread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">printOdd</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">while</span> (currentValue &lt;= MAX_VALUE) {</span><br><span class="line">            <span class="hljs-keyword">try</span> {</span><br><span class="line">                oddSemaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + currentValue);</span><br><span class="line">                currentValue++;</span><br><span class="line">                evenSemaphore.release();</span><br><span class="line">            } <span class="hljs-keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="title function_">printEven</span><span class="hljs-params">()</span> {</span><br><span class="line">        <span class="hljs-keyword">while</span> (currentValue &lt;= MAX_VALUE) {</span><br><span class="line">            <span class="hljs-keyword">try</span> {</span><br><span class="line">                evenSemaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + currentValue);</span><br><span class="line">                currentValue++;</span><br><span class="line">                oddSemaphore.release();</span><br><span class="line">            } <span class="hljs-keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>In this code, we define a <code>OddEvenPrinter</code> class that has a <code>MAX_VALUE</code> constant that specifies the maximum number to print, and a <code>currentValue</code> variable that keeps track of the current number to print.</p><p>We create two <code>Semaphore</code> objects, <code>oddSemaphore</code> and <code>evenSemaphore</code>, that are used to synchronize access to the shared <code>currentValue</code> variable. The <code>oddSemaphore</code> is initialized with a permit count of 1, and the <code>evenSemaphore</code> is initialized with a permit count of 0.</p><p>We create two separate threads, one for printing odd numbers and one for printing even numbers, using the <code>Thread</code> class and lambda expressions.</p><p>The <code>printOdd()</code> and <code>printEven()</code> methods use the <code>acquire()</code> and <code>release()</code> methods of the <code>Semaphore</code> class to ensure that only one thread can access the shared <code>currentValue</code> variable at a time.</p><p>Within each method, we use a <code>while</code> loop to print odd and even numbers, respectively. If the current value is odd and the current thread is the odd thread, we acquire a permit from the <code>oddSemaphore</code>, print the current value, increment the <code>currentValue</code> variable, and release a permit to the <code>evenSemaphore</code>. If the current value is even and the current thread is the even thread, we acquire a permit from the <code>evenSemaphore</code>, print the current value, increment the <code>currentValue</code> variable, and release a permit to the <code>oddSemaphore</code>.</p><p>By the end of this code, you should have two separate threads that print odd and even numbers in order using Semaphores.</p><h2 id="synchronized-vs-Semaphore"><a href="#synchronized-vs-Semaphore" class="headerlink" title="synchronized vs Semaphore:"></a><code>synchronized</code> vs <code>Semaphore</code>:</h2><p>In terms of performance, Semaphores are generally faster and more efficient than synchronized methods for managing concurrency in Java. This is because Semaphores involve less overhead than synchronized methods, and they allow for more fine-grained control over access to shared resources.</p><p>For this problem, both approaches (synchronized methods and Semaphores) are viable solutions and will produce correct results. However, since Semaphores are more efficient than synchronized methods, using Semaphores would be the better choice for this problem in terms of performance.</p><p>In the Semaphore implementation of the Odd Even problem, we use two Semaphores to control access to the shared <code>currentValue</code> variable. The <code>oddSemaphore</code> is initialized with a permit count of 1, and the <code>evenSemaphore</code> is initialized with a permit count of 0. This allows us to ensure that only one thread can access the shared <code>currentValue</code> variable at a time, and that the threads take turns printing odd and even numbers.</p><p>Overall, using Semaphores is a good choice for managing concurrency in Java applications, especially when performance is a concern. However, it’s important to note that Semaphores can be more difficult to use correctly than synchronized methods, and they require more careful design and testing to ensure that they work as intended.</p></body></html>]]></content:encoded>
      
      
      <category domain="https://blog.karthickshiva.dev/categories/operating-system/">Operating System</category>
      
      
      <category domain="https://blog.karthickshiva.dev/tags/multi-threading/">multi-threading</category>
      
      
      <comments>https://blog.karthickshiva.dev/2023/04/22/Using-Threading-to-Print-Odd-and-Even-Numbers-in-Order/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://blog.karthickshiva.dev/2023/04/22/hello-world/</link>
      <guid>https://blog.karthickshiva.dev/2023/04/22/hello-world/</guid>
      <pubDate>Sat, 22 Apr 2023 04:30:00 GMT</pubDate>
      
      <description>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello and welcome to my new blog! My name is Karthick Shiva and I’m a software developer with a passion for all things technical. I’ve been working in the field for several years now, and I’ve had the opportunity to work on a wide variety of subjects across different domains.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</description>
      
      
      
      <content:encoded><![CDATA[<html><head></head><body><p>Hello and welcome to my new blog! My name is Karthick Shiva and I’m a software developer with a passion for all things technical. I’ve been working in the field for several years now, and I’ve had the opportunity to work on a wide variety of subjects across different domains.</p><span id="more"></span><p>I’ve always been interested in sharing my knowledge and experiences with others, which is why I decided to start this blog. Here, I plan to write about a range of technical topics that I find interesting, from programming languages and frameworks to software architecture and design patterns.</p><p>My goal with this blog is to provide valuable insights and practical advice to fellow developers and anyone else who is interested in technology. Whether you’re a seasoned pro or just starting out, I hope you’ll find something useful and informative here.</p><p>In addition to writing about technical topics, I also plan to share my thoughts on industry trends, news, and events. I believe that staying up-to-date on the latest developments in the field is essential for any developer, and I hope to provide a fresh perspective on the topics that matter most.</p><p>So, if you’re interested in learning more about software development, technology, and the industry as a whole, I invite you to join me on this journey. I’m excited to share my knowledge and experiences with you, and I look forward to hearing your thoughts and feedback along the way.</p><p>Thanks for reading, and stay tuned for more posts to come!</p></body></html>]]></content:encoded>
      
      
      <category domain="https://blog.karthickshiva.dev/categories/misc/">Misc</category>
      
      
      <category domain="https://blog.karthickshiva.dev/tags/misc/">misc</category>
      
      
      <comments>https://blog.karthickshiva.dev/2023/04/22/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
